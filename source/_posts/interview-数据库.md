---
title: interview-数据库
date: 2017-04-23 18:35:43
tags: [SQL,Interview]
categories: Interview
---

# 脏读 不可重复读 幻读
## 脏读
A事务访问数据并修改数据,事务未提交时
B事务来`读取`已修改的数据.
A事务回滚,放弃修改,那么B事务读到的就是脏数据
## 不可重复读
A事务第一次读取数据(比如前10条)
B事务`update`第1条数据,commit
A事务第二次读取数据(前10条),和第一次读取有差异
## 幻读
A事务第一次读取全部数据行(共10条)
B事务`insert`一条数据,commit
A事务第二次读取全部数据行(共11条),和第一次读取有差异



# 事务隔离级别
| 隔离级别       | 脏读           |  不可重复读     | 幻读  |
| ------------- |:-------------:| :-------------:| -----:|
| Read uncommitted (读未提交)| √ | √ | √ |
| Read committed (读已提交)  | x | √ | √ |
| Repeatable read (可重复读) | x | x | √ |
| Serializable (可串行化)    | x | x | x |




# 索引
[参考链接](http://blog.csdn.net/kennyrose/article/details/7532032)
## 聚集索引和非聚集索引
* 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个
* 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续.

## 索引的实现
通常使用B树及其变种B+树。

## 索引的作用
* 唯一性索引可以保证数据库表中每一行数据的唯一性。
* 加快数据的检索速度，这也是创建索引的最主要的原因。
* 加速表和表之间的连接.
* 在使用分组和排序子句进行数据检索时，显著减少查询中分组和排序的时间。
* 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

## 索引不利的方面
* 创建索引和维护索引要耗费时间,这种时间随着数据量的增加而增加。
* 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
* 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

## 哪些列适合创建索引
* 在经常需要`搜索`的列上；
* 在作为`主键`的列上，强制该列的唯一性和组织表中数据的排列结构；
* 在经常用在`连接`的列上，这些列主要是一些外键，可以加快连接的速度；
* 在经常需要根据`范围进行搜索`的列上创建索引，因为索引已经排序，其指定的范围是连续的；
* 在经常需要`排序`的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
* 在经常使用在`WHERE子句`中的列上面创建索引，加快条件的判断速度。

## 哪些列不适合创建索引
* 对于那些在查询中`很少使用或者参考的列`不应该创建索引。
* 对于那些只有`很少数据值`的列也不应该增加索引。
* 对于那些定义为`text, image和bit数据类型`的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
* 当`修改性能远远大于检索性能`时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

## 索引失效的情况
* `IN/OR`字句
* `IS NULL`和`IS NOT NULL`
* 使用`函数`
* `类型转换`
* 使用`后模糊` %XXX 不走索引, XXX%走索引
