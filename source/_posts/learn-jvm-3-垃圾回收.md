---
title: learn-jvm-3-垃圾回收
date: 2017-03-08 10:39:58
tags: [Java,jvm]
categories: Java
---


# 何时进行回收
一般来说，当某个区域内存不够的时候就会进行垃圾收集
* young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。
* full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，
则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；
或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；
或者System.gc()、heap dump带GC，默认也是触发full GC。

# 如何判断一块内存是垃圾?

## 引用计数
当有对象引用自身时，就会计数器加1，删除一个引用就减一，当计数为0时即可判断为垃圾.
存在的问题:引用计数存在循环引用问题

## 可达性分析(根搜索算法)
通过一些根节点开始，分析引用链，没有被引用的对象都可以被标记为垃圾对象。
JVM普遍采用该算法

### GC Roots
Java虚拟机将以下对象定义为 GC Roots:
* Java虚拟机栈中引用的对象：比如方法里面定义这种局部变量 User user= new User();
* 静态属性引用的对象：比如 private static User user = new User();
* 常量引用的对象：比如 private static final  User user = new User();
* 本地方法栈中引用的对象

### 引用链不可达标记
即便引用链不可达，也并不意味着该对象一定会被回收，因为回收要经历**两次标记**过程！
**第一次标记**：对象进行根搜索之后，如果发现没有与GC Roots 相连接的引用链，就会被第一次标记并进行筛选。所谓筛选，就是检查此对象是否有必要执行finalize方法，如果对象定义了该方法并且没有执行过。那么该对象就会被放入到一个队列F-Queue，随后会有一个低优先级的线程去执行这个队列里面对象的finalize方法
**第二次标记**：JVM 将对F-Queue队列里面的对象进行第二次标记。如果对象不想被回收，那么就得在finalize方法里面拯救自己，否则，这些对象就真的会被回收

---
# 垃圾回收算法
## 标记清除
对非垃圾对象进行标记，清除其他的对象。
存在的问题:这种方式对对内存空间造成空隙，即内存碎片，最终导致有空余空间，但没有连续的足够大小的空间分配内存。

## 标记整理
标记非垃圾对象后，将这些对象整理好，依次排列内存。
存在的问题:这样内存就是整齐的了。但是因为会造成对象移动，所以效率会有降低。~

## 标记清除整理
即组合`标记清除`和`标记整理`两种方式，在若干次清除后进行一次整理。

## 复制
划分成两个相同大小的区域，收集时，将第一个区域的活对象复制到另一个区域.
这样不会有内存碎片问题。但是最多只能存放一半内存,而且所有的活对象都需要拷贝。
将内存分为一块较大的eden空间和2块较少的survivor空间，
每次使用eden和其中一块survivor，
当回收时将eden和 survivor还存活的对象一次过拷贝到另外一块survivor空间上，
然后清理掉eden和用过的survivor。
Sun Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的。

## 分代回收
* 对于新生代的对象回收,使用复制算法
* 对于老年代的对象回收,使用标记-清除算法