---
title: learn-jvm-3-垃圾回收
tags: [Java,jvm]
categories: Java
---


# 何时进行回收
一般来说，当某个区域内存不够的时候就会进行垃圾收集

# 如何判断一块内存是垃圾?

## 引用计数
当有对象引用自身时，就会计数器加1，删除一个引用就减一，当计数为0时即可判断为垃圾.
存在的问题:引用计数存在循环引用问题

## 可达性分析(根搜索算法)
通过一些根节点开始，分析引用链，没有被引用的对象都可以被标记为垃圾对象。
JVM普遍采用该算法
Java虚拟机将以下对象定义为 GC Roots:
* Java虚拟机栈中引用的对象：比如方法里面定义这种局部变量 User user= new User();
* 静态属性引用的对象：比如 private static User user = new User();
* 常量引用的对象：比如 private static final  User user = new User();
* 本地方法栈中引用的对象

---
# 垃圾回收算法
## 标记清除
对非垃圾对象进行标记，清除其他的对象。
存在的问题:这种方式对对内存空间造成空隙，即内存碎片，最终导致有空余空间，但没有连续的足够大小的空间分配内存。

## 标记整理
标记非垃圾对象后，将这些对象整理好，依次排列内存。
存在的问题:这样内存就是整齐的了。但是因为会造成对象移动，所以效率会有降低。~

## 标记清除整理
即组合`标记清除`和`标记整理`两种方式，在若干次清除后进行一次整理。

## 复制
划分成两个相同大小的区域，收集时，将第一个区域的活对象复制到另一个区域.
这样不会有内存碎片问题。但是最多只能存放一半内存,而且所有的活对象都需要拷贝。
将内存分为一块较大的eden空间和2块较少的survivor空间，
每次使用eden和其中一块survivor，
当回收时将eden和 survivor还存活的对象一次过拷贝到另外一块survivor空间上，
然后清理掉eden和用过的survivor。
Sun Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的。

## 分代回收
* 对于新生代的对象回收,使用复制算法
* 对于老年代的对象回收,使用标记-清除算法